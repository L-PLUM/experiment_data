/**
 *Submitted for verification at Etherscan.io on 2019-08-07
*/

// Generated by Jthereum BETA version!
interface ERC20
{
	function balanceOf(address who) external view returns (uint256);
	function transfer(address to, uint256 value) external returns (bool);
	function allowance(address owner, address spender) external view returns (uint256);
	function transferFrom(address from, address to, uint256 value) external returns (bool);
	function approve(address spender, uint256 value) external returns (bool);
	function name() external view returns (string memory);
	function symbol() external view returns (string memory);


	event Transfer(address indexed from, address indexed to, uint256 value);

	event Approval(address indexed owner, address indexed spender, uint256 value);

}

// Generated by Jthereum BETA version!
pragma solidity ^0.5.9;
contract ERC20TokenReceiver
{
	mapping (address => mapping (address => uint256)) private balancesByTokenContractAddressByUser;
	function takeMyTokensPlease(address tokenContractAddress, uint256 amount) public 
	{
		ERC20 token = ERC20(tokenContractAddress);
		if (!token.transferFrom(msg.sender, address(this), amount)) 
		{
			emit TokenPaymentFailed(msg.sender, tokenContractAddress, amount);
			return;
		}
		(balancesByTokenContractAddressByUser[msg.sender][tokenContractAddress] += amount);
		emit ReceivedTokenPayment(msg.sender, tokenContractAddress, amount);
	}
	function giveMeBackAllMyTokens(address tokenContractAddress) public 
	{
		uint256 amount = balancesByTokenContractAddressByUser[msg.sender][tokenContractAddress];
		if ((amount == 0)) 
		{
			emit TokenPaymentReturnFailed(msg.sender, tokenContractAddress, 0);
			return;
		}
		ERC20 token = ERC20(tokenContractAddress);
		if (!token.transfer(msg.sender, amount)) 
		{
			emit TokenPaymentReturnFailed(msg.sender, tokenContractAddress, 1);
			return;
		}
		balancesByTokenContractAddressByUser[msg.sender][tokenContractAddress] = 0;
		emit TokenPaymentReturned(msg.sender, tokenContractAddress, amount);
	}
	function balanceOf(address tokenContractAddress, address owner) public view returns (uint256) 
	{
		return balancesByTokenContractAddressByUser[owner][tokenContractAddress];
	}
	function doesThisContractExist() public pure returns (bool) 
	{
		return true;
	}
	event ReceivedTokenPayment(address indexed from, address indexed tokenContract, uint256 amount);

	event TokenPaymentReturned(address indexed from, address indexed tokenContract, uint256 amount);

	event TokenPaymentReturnFailed(address indexed from, address indexed tokenContract, int32 failureReason);

	event TokenPaymentFailed(address indexed from, address indexed tokenContract, uint256 amount);



	// Imported Event declarations
	event Transfer(address indexed from, address indexed to, uint256 value);

	event Approval(address indexed owner, address indexed spender, uint256 value);


}
