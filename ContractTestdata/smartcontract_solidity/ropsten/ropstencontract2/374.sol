/**
 *Submitted for verification at Etherscan.io on 2019-08-07
*/

// Generated by Jthereum BETA version!
pragma solidity ^0.5.9;
contract FINNEYToken
{
	// Adding field from class com.u7.jthereum.baseContractImplementations.BaseERC20Token with signature Uint256 _totalSupply
	uint256 public _totalSupply = uint256(0);

	// Adding field from class com.u7.jthereum.baseContractImplementations.BaseERC20Token with signature Mapping<Address, Uint256> balancesByAddress
	mapping (address => uint256) internal balancesByAddress;

	// Adding field from class com.u7.jthereum.baseContractImplementations.BaseERC20Token with signature Mapping<Address, Mapping<Address, Uint256>> allowancesBySpenderByOwner
	mapping (address => mapping (address => uint256)) internal allowancesBySpenderByOwner;

	string private _name = "FINNEY == 1/1,000 of 1 ETH.";
	string private _symbol = "FINNEY";
	uint256 private ratio = uint256(1_000);


	// Adding method from class com.u7.jthereum.tokens.denominations.BaseDenominationToken with signature void buy()
	function buy() public payable 
	{
		uint256 numberOfTokensBeingPurchased = (ratio * msg.value);
		(_totalSupply += numberOfTokensBeingPurchased);
		uint256 newBalance = (balancesByAddress[msg.sender] + numberOfTokensBeingPurchased);
		require((newBalance > balancesByAddress[msg.sender]));
		balancesByAddress[msg.sender] = newBalance;
		emit Transfer(address(0), msg.sender, numberOfTokensBeingPurchased);
		emit Purchase(msg.sender, numberOfTokensBeingPurchased);
	}

	// Adding method from class com.u7.jthereum.tokens.denominations.BaseDenominationToken with signature void fallbackFunction()
	function () external payable 
	{
		buy();
	}

	// Adding method from class com.u7.jthereum.tokens.denominations.BaseDenominationToken with signature void redeem(Uint256)
	function redeem(uint256 amount) public 
	{
		uint256 amountOfETH = (amount / ratio);
		amount = (amountOfETH * ratio);
		uint256 newBalance = (balancesByAddress[msg.sender] - amount);
		require((newBalance < balancesByAddress[msg.sender]));
		balancesByAddress[msg.sender] = newBalance;
		(_totalSupply -= amount);
		emit Redeem(msg.sender, amount);
		emit Transfer(msg.sender, address(0), amount);
		msg.sender.transfer(amountOfETH);
	}

	// Adding method from class com.u7.jthereum.tokens.denominations.BaseDenominationToken with signature void redeemAll()
	function redeemAll() public 
	{
		redeem(balancesByAddress[msg.sender]);
		uint256 subWeiResidueBalance = balancesByAddress[msg.sender];
		if ((subWeiResidueBalance == 0)) 
		{
			return;
		}
		(_totalSupply -= subWeiResidueBalance);
		emit Transfer(msg.sender, address(0), subWeiResidueBalance);
		balancesByAddress[msg.sender] = 0;
	}

	// Adding method from class com.u7.jthereum.baseContractImplementations.BaseERC20Token with signature String name()
	function name() public view returns (string memory) 
	{
		return _name;
	}

	// Adding method from class com.u7.jthereum.baseContractImplementations.BaseERC20Token with signature String symbol()
	function symbol() public view returns (string memory) 
	{
		return _symbol;
	}

	// Adding method from class com.u7.jthereum.baseContractImplementations.BaseERC20Token with signature Uint8 decimals()
	function decimals() public pure returns (uint8) 
	{
		return 18;
	}

	// Adding method from class com.u7.jthereum.baseContractImplementations.BaseERC20Token with signature Uint256 balanceOf(Address)
	function balanceOf(address who) public view returns (uint256) 
	{
		return balancesByAddress[who];
	}

	// Adding method from class com.u7.jthereum.baseContractImplementations.BaseERC20Token with signature Uint256 totalSupply()
	function totalSupply() public view returns (uint256) 
	{
		return _totalSupply;
	}

	// Adding method from class com.u7.jthereum.baseContractImplementations.BaseERC20Token with signature boolean transfer(Address, Uint256)
	function transfer(address to, uint256 value) public returns (bool) 
	{
		return internalTransfer(msg.sender, to, value);
	}

	// Adding method from class com.u7.jthereum.baseContractImplementations.BaseERC20Token with signature boolean approve(Address, Uint256)
	function approve(address spender, uint256 value) public returns (bool) 
	{
		allowancesBySpenderByOwner[msg.sender][spender] = value;
		emit Approval(msg.sender, spender, value);
		return true;
	}

	// Adding method from class com.u7.jthereum.baseContractImplementations.BaseERC20Token with signature Uint256 allowance(Address, Address)
	function allowance(address owner, address spender) public view returns (uint256) 
	{
		return allowancesBySpenderByOwner[owner][spender];
	}

	// Adding method from class com.u7.jthereum.baseContractImplementations.BaseERC20Token with signature boolean transferFrom(Address, Address, Uint256)
	function transferFrom(address from, address to, uint256 value) public returns (bool) 
	{
		uint256 allowanceAmount = allowance(from, to);
		require((allowanceAmount >= value));
		mapping (address => uint256) storage allowancesBySpender = allowancesBySpenderByOwner[from];
		allowancesBySpender[to] = (allowanceAmount - value);
		return internalTransfer(from, to, value);
	}

	// Adding method from class com.u7.jthereum.baseContractImplementations.BaseERC20Token with signature boolean internalTransfer(Address, Address, Uint256)
	function internalTransfer(address from, address to, uint256 value) private returns (bool) 
	{
		uint256 newSenderBalance = (balancesByAddress[from] - value);
		uint256 newToBalance = (balancesByAddress[to] + value);
		require((balancesByAddress[from] >= value));
		require((newToBalance >= balancesByAddress[to]));
		balancesByAddress[from] = newSenderBalance;
		balancesByAddress[to] = newToBalance;
		emit Transfer(from, to, value);
		return true;
	}

	// Imported Event declarations
	event Purchase(address indexed buyer, uint256 value);

	event Redeem(address indexed seller, uint256 value);

	event Transfer(address indexed from, address indexed to, uint256 value);

	event Approval(address indexed owner, address indexed spender, uint256 value);


}
